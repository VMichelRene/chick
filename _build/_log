### Starting build.
# Target: test.ml.depends, tags: { extension:ml, file:test.ml, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules test.ml > test.ml.depends
+ /usr/bin/ocamldep.opt -modules test.ml > test.ml.depends
File "test.ml", line 25, characters 11-13:
25 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle antisymetrique\\\\\n" 
                ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 25, characters 32-34:
25 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle antisymetrique\\\\\n" 
                                     ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 25, characters 38-40:
25 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle antisymetrique\\\\\n" 
                                           ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 25, characters 59-61:
25 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle antisymetrique\\\\\n" 
                                                                ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 25, characters 72-74:
25 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle antisymetrique\\\\\n" 
                                                                             ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 35, characters 11-13:
35 |   printf "$\overbrace{%s}^{%s}$ Règle 1\\\\ \n" (M.to_s i2) n2;
                ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 42, characters 11-13:
42 |   printf "$\overbrace{%s}^{%s}$ Règle 2\\\\ \n" (M.to_s i2) n2;
                ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 49, characters 11-13:
49 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle 3\\\\\n" 
                ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 49, characters 32-34:
49 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle 3\\\\\n" 
                                     ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 49, characters 38-40:
49 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle 3\\\\\n" 
                                           ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 49, characters 59-61:
49 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle 3\\\\\n" 
                                                                ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 49, characters 72-74:
49 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle 3\\\\\n" 
                                                                             ^^
Warning 14: illegal backslash escape in string.
# Target: Struct/ens.ml.depends, tags: { extension:ml, file:Struct/ens.ml, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Struct/ens.ml > Struct/ens.ml.depends
# Target: Parser/P1/lexerP1.mll, tags: { extension:mll, file:Parser/P1/lexerP1.mll, lexer, ocaml, ocamllex, quiet }
/usr/bin/ocamllex.opt -q Parser/P1/lexerP1.mll
# Target: Parser/P1/lexerP1.ml.depends, tags: { extension:ml, file:Parser/P1/lexerP1.ml, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Parser/P1/lexerP1.ml > Parser/P1/lexerP1.ml.depends
# Target: Parser/P1/parserP1.mly, tags: { extension:mly, file:Parser/P1/parserP1.mly, infer, ocaml, ocamlyacc, parser, quiet }
/usr/bin/ocamlyacc Parser/P1/parserP1.mly
# Target: Parser/P1/parserP1.mli.depends, tags: { extension:mli, file:Parser/P1/parserP1.mli, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Parser/P1/parserP1.mli > Parser/P1/parserP1.mli.depends
# Target: Parser/P1/parserTypeP1.ml.depends, tags: { extension:ml, file:Parser/P1/parserTypeP1.ml, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Parser/P1/parserTypeP1.ml > Parser/P1/parserTypeP1.ml.depends
# Target: Parser/P1/parserTypeP1.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:Parser/P1/parserTypeP1.cmo, file:Parser/P1/parserTypeP1.ml, implem, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Parser/P1 -I Struct -I Outils -I Parser/P4 -I Parser/P3 -I Parser/P2 -o Parser/P1/parserTypeP1.cmo Parser/P1/parserTypeP1.ml
# Target: Parser/P1/parserP1.cmi, tags: { byte, compile, extension:mli, file:Parser/P1/parserP1.mli, interf, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Parser/P1 -I Struct -I Outils -I Parser/P4 -I Parser/P3 -I Parser/P2 -o Parser/P1/parserP1.cmi Parser/P1/parserP1.mli
# Target: Parser/P1/lexerP1.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:Parser/P1/lexerP1.cmo, file:Parser/P1/lexerP1.ml, implem, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Parser/P1 -I Struct -I Outils -I Parser/P4 -I Parser/P3 -I Parser/P2 -o Parser/P1/lexerP1.cmo Parser/P1/lexerP1.ml
# Target: Struct/magma_commutatif_re_equiv.ml.depends, tags: { extension:ml, file:Struct/magma_commutatif_re_equiv.ml, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Struct/magma_commutatif_re_equiv.ml > Struct/magma_commutatif_re_equiv.ml.depends
# Target: Struct/e.ml.depends, tags: { extension:ml, file:Struct/e.ml, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Struct/e.ml > Struct/e.ml.depends
# Target: Struct/l.ml.depends, tags: { extension:ml, file:Struct/l.ml, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Struct/l.ml > Struct/l.ml.depends
# Target: Parser/P4/lexerP4.mll, tags: { extension:mll, file:Parser/P4/lexerP4.mll, lexer, ocaml, ocamllex, quiet }
/usr/bin/ocamllex.opt -q Parser/P4/lexerP4.mll
# Target: Parser/P4/lexerP4.ml.depends, tags: { extension:ml, file:Parser/P4/lexerP4.ml, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Parser/P4/lexerP4.ml > Parser/P4/lexerP4.ml.depends
# Target: Parser/P4/parserP4.mly, tags: { extension:mly, file:Parser/P4/parserP4.mly, infer, ocaml, ocamlyacc, parser, quiet }
/usr/bin/ocamlyacc Parser/P4/parserP4.mly
# Target: Parser/P4/parserP4.mli.depends, tags: { extension:mli, file:Parser/P4/parserP4.mli, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Parser/P4/parserP4.mli > Parser/P4/parserP4.mli.depends
# Target: Parser/P4/parserTypeP4.ml.depends, tags: { extension:ml, file:Parser/P4/parserTypeP4.ml, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Parser/P4/parserTypeP4.ml > Parser/P4/parserTypeP4.ml.depends
# Target: Parser/P4/parserTypeP4.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:Parser/P4/parserTypeP4.cmo, file:Parser/P4/parserTypeP4.ml, implem, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Parser/P4 -I Struct -I Outils -I Parser/P1 -I Parser/P3 -I Parser/P2 -o Parser/P4/parserTypeP4.cmo Parser/P4/parserTypeP4.ml
# Target: Parser/P4/parserP4.cmi, tags: { byte, compile, extension:mli, file:Parser/P4/parserP4.mli, interf, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Parser/P4 -I Struct -I Outils -I Parser/P1 -I Parser/P3 -I Parser/P2 -o Parser/P4/parserP4.cmi Parser/P4/parserP4.mli
# Target: Struct/magma_commutatif.ml.depends, tags: { extension:ml, file:Struct/magma_commutatif.ml, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Struct/magma_commutatif.ml > Struct/magma_commutatif.ml.depends
# Target: Struct/e.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:Struct/e.cmo, file:Struct/e.ml, implem, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Struct -I Outils -I Parser/P1 -I Parser/P4 -I Parser/P3 -I Parser/P2 -o Struct/e.cmo Struct/e.ml
# Target: Struct/l.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:Struct/l.cmo, file:Struct/l.ml, implem, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Struct -I Outils -I Parser/P1 -I Parser/P4 -I Parser/P3 -I Parser/P2 -o Struct/l.cmo Struct/l.ml
# Target: Struct/magma.ml.depends, tags: { extension:ml, file:Struct/magma.ml, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Struct/magma.ml > Struct/magma.ml.depends
# Target: Parser/P3/lexerP3.mll, tags: { extension:mll, file:Parser/P3/lexerP3.mll, lexer, ocaml, ocamllex, quiet }
/usr/bin/ocamllex.opt -q Parser/P3/lexerP3.mll
# Target: Parser/P3/lexerP3.ml.depends, tags: { extension:ml, file:Parser/P3/lexerP3.ml, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Parser/P3/lexerP3.ml > Parser/P3/lexerP3.ml.depends
# Target: Parser/P3/parserP3.mly, tags: { extension:mly, file:Parser/P3/parserP3.mly, infer, ocaml, ocamlyacc, parser, quiet }
/usr/bin/ocamlyacc Parser/P3/parserP3.mly
# Target: Parser/P3/parserP3.mli.depends, tags: { extension:mli, file:Parser/P3/parserP3.mli, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Parser/P3/parserP3.mli > Parser/P3/parserP3.mli.depends
# Target: Parser/P3/parserTypeP3.ml.depends, tags: { extension:ml, file:Parser/P3/parserTypeP3.ml, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Parser/P3/parserTypeP3.ml > Parser/P3/parserTypeP3.ml.depends
# Target: Parser/P3/parserTypeP3.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:Parser/P3/parserTypeP3.cmo, file:Parser/P3/parserTypeP3.ml, implem, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Parser/P3 -I Struct -I Outils -I Parser/P1 -I Parser/P4 -I Parser/P2 -o Parser/P3/parserTypeP3.cmo Parser/P3/parserTypeP3.ml
# Target: Parser/P3/parserP3.cmi, tags: { byte, compile, extension:mli, file:Parser/P3/parserP3.mli, interf, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Parser/P3 -I Struct -I Outils -I Parser/P1 -I Parser/P4 -I Parser/P2 -o Parser/P3/parserP3.cmi Parser/P3/parserP3.mli
# Target: Outils/outils.ml.depends, tags: { extension:ml, file:Outils/outils.ml, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Outils/outils.ml > Outils/outils.ml.depends
# Target: Parser/P3/lexerP3.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:Parser/P3/lexerP3.cmo, file:Parser/P3/lexerP3.ml, implem, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Parser/P3 -I Struct -I Outils -I Parser/P1 -I Parser/P4 -I Parser/P2 -o Parser/P3/lexerP3.cmo Parser/P3/lexerP3.ml
# Target: Outils/outils.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:Outils/outils.cmo, file:Outils/outils.ml, implem, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Outils -I Struct -I Parser/P1 -I Parser/P4 -I Parser/P3 -I Parser/P2 -o Outils/outils.cmo Outils/outils.ml
# Target: Struct/magma.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:Struct/magma.cmo, file:Struct/magma.ml, implem, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Struct -I Outils -I Parser/P1 -I Parser/P4 -I Parser/P3 -I Parser/P2 -o Struct/magma.cmo Struct/magma.ml
+ /usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Struct -I Outils -I Parser/P1 -I Parser/P4 -I Parser/P3 -I Parser/P2 -o Struct/magma.cmo Struct/magma.ml
File "Struct/magma.ml", line 27, characters 10-31:
27 |  let p1 = function L (a,_) -> a
               ^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Elt _
File "Struct/magma.ml", line 28, characters 10-31:
28 |  let p2 = function L (_,b) -> b
               ^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Elt _
# Target: Struct/r.ml.depends, tags: { extension:ml, file:Struct/r.ml, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Struct/r.ml > Struct/r.ml.depends
# Target: Parser/P4/lexerP4.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:Parser/P4/lexerP4.cmo, file:Parser/P4/lexerP4.ml, implem, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Parser/P4 -I Struct -I Outils -I Parser/P1 -I Parser/P3 -I Parser/P2 -o Parser/P4/lexerP4.cmo Parser/P4/lexerP4.ml
# Target: Struct/magma_commutatif.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:Struct/magma_commutatif.cmo, file:Struct/magma_commutatif.ml, implem, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Struct -I Outils -I Parser/P1 -I Parser/P4 -I Parser/P3 -I Parser/P2 -o Struct/magma_commutatif.cmo Struct/magma_commutatif.ml
# Target: Struct/r.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:Struct/r.cmo, file:Struct/r.ml, implem, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Struct -I Outils -I Parser/P1 -I Parser/P4 -I Parser/P3 -I Parser/P2 -o Struct/r.cmo Struct/r.ml
# Target: Struct/ens.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:Struct/ens.cmo, file:Struct/ens.ml, implem, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Struct -I Outils -I Parser/P1 -I Parser/P4 -I Parser/P3 -I Parser/P2 -o Struct/ens.cmo Struct/ens.ml
# Target: Struct/magma_commutatif_re_equiv.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:Struct/magma_commutatif_re_equiv.cmo, file:Struct/magma_commutatif_re_equiv.ml, implem, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Struct -I Outils -I Parser/P1 -I Parser/P4 -I Parser/P3 -I Parser/P2 -o Struct/magma_commutatif_re_equiv.cmo Struct/magma_commutatif_re_equiv.ml
+ /usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Struct -I Outils -I Parser/P1 -I Parser/P4 -I Parser/P3 -I Parser/P2 -o Struct/magma_commutatif_re_equiv.cmo Struct/magma_commutatif_re_equiv.ml
File "Struct/magma_commutatif_re_equiv.ml", line 35, characters 18-199:
35 | ..................function
36 |        | M1 a                -> Elt  (M.from_s a) 
37 |        | Inf (M1 a, M1 b)    -> Re   (M.from_s a,M.from_s b)
38 |        | Eq  (M1 a, M1 b)    -> Egal (M.from_s a,M.from_s b)
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Inf (M1 _, (Inf (_, _)|Eq (_, _)))|Inf ((Inf (_, _)|Eq (_, _)), _)|
Eq (M1 _, (Inf (_, _)|Eq (_, _)))|Eq ((Inf (_, _)|Eq (_, _)), _))
File "Struct/magma_commutatif_re_equiv.ml", line 45, characters 27-75:
45 |   let createElt          = function (Elt a, Elt b) -> Elt (M.createL (a,b)) 
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Elt _, Re (_, _))
File "Struct/magma_commutatif_re_equiv.ml", line 46, characters 27-62:
46 |   let createRe           = function (Elt a, Elt b) -> Re (a,b) 
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Elt _, Re (_, _))
File "Struct/magma_commutatif_re_equiv.ml", line 47, characters 27-64:
47 |   let createEgal         = function (Elt a, Elt b) -> Egal (a,b) 
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Elt _, Re (_, _))
File "Struct/magma_commutatif_re_equiv.ml", line 49, characters 13-45:
49 |   let p1   = function Elt a   -> Elt (M.p1 a)    (* p1 a*b = a *) 
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Re (_, _)
File "Struct/magma_commutatif_re_equiv.ml", line 50, characters 13-45:
50 |   let p2   = function Elt a   -> Elt (M.p2 a)    (* p1 a*b = a *) 
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Re (_, _)
File "Struct/magma_commutatif_re_equiv.ml", line 58, characters 15-177:
58 | ...............function
59 |     | (Re    (x1,y1),Egal (x2,y2)) when x1=x2 -> createRe    (Elt y2,Elt y1)
60 |     | (Egal  (x1,y1),Egal (x2,y2)) when x1=x2 -> createEgal  (Elt y2,Elt y1)
Warning 8: this pattern-matching is not exhaustive.
All clauses in this pattern-matching are guarded.
File "Struct/magma_commutatif_re_equiv.ml", line 62, characters 15-177:
62 | ...............function
63 |     | (Re    (x1,y1),Egal (x2,y2)) when y1=x2 -> createRe    (Elt x1,Elt y2)
64 |     | (Egal  (x1,y1),Egal (x2,y2)) when y1=x2 -> createEgal  (Elt x1,Elt y2)
Warning 8: this pattern-matching is not exhaustive.
All clauses in this pattern-matching are guarded.
# Target: test.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:test.cmo, file:test.ml, implem, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Struct -I Outils -I Parser/P1 -I Parser/P4 -I Parser/P3 -I Parser/P2 -o test.cmo test.ml
+ /usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Struct -I Outils -I Parser/P1 -I Parser/P4 -I Parser/P3 -I Parser/P2 -o test.cmo test.ml
File "test.ml", line 25, characters 11-13:
25 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle antisymetrique\\\\\n" 
                ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 25, characters 32-34:
25 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle antisymetrique\\\\\n" 
                                     ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 25, characters 38-40:
25 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle antisymetrique\\\\\n" 
                                           ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 25, characters 59-61:
25 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle antisymetrique\\\\\n" 
                                                                ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 25, characters 72-74:
25 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle antisymetrique\\\\\n" 
                                                                             ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 35, characters 11-13:
35 |   printf "$\overbrace{%s}^{%s}$ Règle 1\\\\ \n" (M.to_s i2) n2;
                ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 42, characters 11-13:
42 |   printf "$\overbrace{%s}^{%s}$ Règle 2\\\\ \n" (M.to_s i2) n2;
                ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 49, characters 11-13:
49 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle 3\\\\\n" 
                ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 49, characters 32-34:
49 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle 3\\\\\n" 
                                     ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 49, characters 38-40:
49 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle 3\\\\\n" 
                                           ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 49, characters 59-61:
49 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle 3\\\\\n" 
                                                                ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 49, characters 72-74:
49 |   printf "$\underbrace{%s}_{%s} \land \underbrace{%s}_{%s} \Rightarrow $\overbrace{%s}^{%s}$ Règle 3\\\\\n" 
                                                                             ^^
Warning 14: illegal backslash escape in string.
File "test.ml", line 16, characters 9-114:
16 | .........function
17 |    (M.Re (x1,a),M.Re (x2,b))  when x1=x2  -> M.createRe (M.Elt x1,M.createElt (M.Elt a,M.Elt b))
Warning 8: this pattern-matching is not exhaustive.
All clauses in this pattern-matching are guarded.
File "test.ml", line 103, characters 2-22:
103 |   ctrl i3 "a+b <= b+a";   
        ^^^^^^^^^^^^^^^^^^^^
Warning 10: this expression should have type unit.
File "test.ml", line 112, characters 2-22:
112 |   ctrl i7 "b+a <= a+b";   
        ^^^^^^^^^^^^^^^^^^^^
Warning 10: this expression should have type unit.
File "test.ml", line 118, characters 2-21:
118 |   ctrl i8 "a+b = b+a";   
        ^^^^^^^^^^^^^^^^^^^
Warning 10: this expression should have type unit.
# Target: Parser/P1/parserP1.ml.depends, tags: { extension:ml, file:Parser/P1/parserP1.ml, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Parser/P1/parserP1.ml > Parser/P1/parserP1.ml.depends
# Target: Parser/P1/parserP1.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:Parser/P1/parserP1.cmo, file:Parser/P1/parserP1.ml, implem, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Parser/P1 -I Struct -I Outils -I Parser/P4 -I Parser/P3 -I Parser/P2 -o Parser/P1/parserP1.cmo Parser/P1/parserP1.ml
# Target: Parser/P4/parserP4.ml.depends, tags: { extension:ml, file:Parser/P4/parserP4.ml, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Parser/P4/parserP4.ml > Parser/P4/parserP4.ml.depends
# Target: Parser/P4/parserP4.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:Parser/P4/parserP4.cmo, file:Parser/P4/parserP4.ml, implem, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Parser/P4 -I Struct -I Outils -I Parser/P1 -I Parser/P3 -I Parser/P2 -o Parser/P4/parserP4.cmo Parser/P4/parserP4.ml
# Target: Parser/P3/parserP3.ml.depends, tags: { extension:ml, file:Parser/P3/parserP3.ml, ocaml, ocamldep, quiet }
/usr/bin/ocamldep.opt -modules Parser/P3/parserP3.ml > Parser/P3/parserP3.ml.depends
# Target: Parser/P3/parserP3.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:Parser/P3/parserP3.cmo, file:Parser/P3/parserP3.ml, implem, ocaml, quiet }
/usr/bin/ocamlc.opt -c -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml -I Parser/P3 -I Struct -I Outils -I Parser/P1 -I Parser/P4 -I Parser/P2 -o Parser/P3/parserP3.cmo Parser/P3/parserP3.ml
# Target: test.byte, tags: { byte, dont_link_with, extension:byte, file:test.byte, link, ocaml, program, quiet }
/usr/bin/ocamlc.opt -I /home/mv/.opam/system/lib/zarith -I /usr/lib/ocaml unix.cma zarith.cma -I Parser/P1 -I Struct -I Parser/P4 -I Outils -I Parser/P3 Parser/P1/parserTypeP1.cmo Parser/P1/parserP1.cmo Parser/P1/lexerP1.cmo Struct/ens.cmo Parser/P4/parserTypeP4.cmo Parser/P4/parserP4.cmo Parser/P4/lexerP4.cmo Struct/e.cmo Struct/l.cmo Outils/outils.cmo Parser/P3/parserTypeP3.cmo Parser/P3/parserP3.cmo Parser/P3/lexerP3.cmo Struct/magma.cmo Struct/magma_commutatif.cmo Struct/r.cmo Struct/magma_commutatif_re_equiv.cmo test.cmo -o test.byte
# Compilation successful.
